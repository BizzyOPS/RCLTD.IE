/**
 * Comprehensive Dependency Vulnerability Scanner
 * Robotics & Control Ltd - Enterprise Security Monitoring
 * 
 * This module provides automated vulnerability scanning for Node.js dependencies
 * with configurable severity thresholds, detailed reporting, and integration
 * with multiple scanning tools.
 */

const { exec, spawn } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const crypto = require('crypto');
const { v4: uuidv4 } = require('uuid');

// ==================== CONFIGURATION ====================

const VULNERABILITY_CONFIG = {
    // Severity thresholds
    severityThresholds: {
        critical: 0,    // Block on any critical vulnerabilities
        high: 3,        // Allow up to 3 high severity vulnerabilities
        moderate: 10,   // Allow up to 10 moderate vulnerabilities
        low: 50         // Allow up to 50 low severity vulnerabilities
    },
    
    // Report settings
    reporting: {
        outputDir: './security-reports',
        retentionDays: 30,
        formats: ['json', 'csv', 'html'],
        includeRemediation: true
    },
    
    // Scanning tools configuration
    tools: {
        npmAudit: {
            enabled: true,
            timeout: 120000, // 2 minutes
            retries: 3
        },
        betterNpmAudit: {
            enabled: true,
            timeout: 120000,
            retries: 3
        },
        auditCi: {
            enabled: true,
            timeout: 180000, // 3 minutes
            retries: 2
        }
    },
    
    // Automation settings
    automation: {
        autoScan: true,
        scanInterval: '0 2 * * *', // Daily at 2 AM
        alertingEnabled: true,
        slackWebhook: process.env.SLACK_WEBHOOK_URL,
        emailAlerts: process.env.SECURITY_EMAIL_ALERTS
    }
};

// ==================== VULNERABILITY SCANNER CLASS ====================

class VulnerabilityScanner {
    constructor(config = VULNERABILITY_CONFIG) {
        this.config = config;
        this.scanHistory = [];
        this.alertThresholds = config.severityThresholds;
        
        // Ensure output directory exists
        this.ensureOutputDirectory();
        
        // Initialize scan tracking
        this.currentScanId = null;
        this.lastScanResults = null;
    }

    /**
     * Ensure the security reports directory exists
     */
    async ensureOutputDirectory() {
        try {
            await fs.ensureDir(this.config.reporting.outputDir);
            console.log(`[SECURITY] Reports directory ready: ${this.config.reporting.outputDir}`);
        } catch (error) {
            console.error('[SECURITY] Failed to create reports directory:', error);
            throw error;
        }
    }

    /**
     * Run comprehensive vulnerability scan using multiple tools
     */
    async runFullScan(options = {}) {
        const scanId = uuidv4();
        this.currentScanId = scanId;
        
        const scanStartTime = new Date();
        console.log(`[SECURITY] Starting comprehensive vulnerability scan ${scanId} at ${scanStartTime.toISOString()}`);
        
        const scanResults = {
            scanId,
            timestamp: scanStartTime.toISOString(),
            status: 'running',
            tools: {},
            summary: {
                totalVulnerabilities: 0,
                critical: 0,
                high: 0,
                moderate: 0,
                low: 0,
                info: 0
            },
            recommendations: [],
            errors: []
        };

        try {
            // Run scans with different tools in parallel for efficiency
            const scanPromises = [];
            
            if (this.config.tools.npmAudit.enabled) {
                scanPromises.push(this.runNpmAudit(scanId));
            }
            
            if (this.config.tools.betterNpmAudit.enabled) {
                scanPromises.push(this.runBetterNpmAudit(scanId));
            }
            
            if (this.config.tools.auditCi.enabled) {
                scanPromises.push(this.runAuditCi(scanId));
            }

            // Wait for all scans to complete
            const toolResults = await Promise.allSettled(scanPromises);
            
            // Process results from all tools
            toolResults.forEach((result, index) => {
                const toolNames = ['npmAudit', 'betterNpmAudit', 'auditCi'];
                const toolName = toolNames[index];
                
                if (result.status === 'fulfilled') {
                    scanResults.tools[toolName] = result.value;
                    this.aggregateVulnerabilities(scanResults.summary, result.value);
                } else {
                    console.error(`[SECURITY] ${toolName} scan failed:`, result.reason);
                    scanResults.errors.push({
                        tool: toolName,
                        error: result.reason.message || 'Unknown error'
                    });
                    scanResults.tools[toolName] = { error: result.reason.message };
                }
            });

            // Generate recommendations
            scanResults.recommendations = this.generateRecommendations(scanResults);
            
            // Finalize scan
            scanResults.status = 'completed';
            scanResults.duration = Date.now() - scanStartTime.getTime();
            scanResults.compliance = this.checkCompliance(scanResults.summary);
            
            // Save results
            await this.saveResults(scanResults);
            
            // Send alerts if necessary
            await this.checkAndSendAlerts(scanResults);
            
            this.lastScanResults = scanResults;
            this.scanHistory.push(scanResults);
            
            console.log(`[SECURITY] Scan ${scanId} completed in ${scanResults.duration}ms`);
            console.log(`[SECURITY] Found ${scanResults.summary.totalVulnerabilities} vulnerabilities`);
            
            return scanResults;
            
        } catch (error) {
            console.error(`[SECURITY] Scan ${scanId} failed:`, error);
            scanResults.status = 'failed';
            scanResults.error = error.message;
            scanResults.duration = Date.now() - scanStartTime.getTime();
            
            await this.saveResults(scanResults);
            throw error;
        }
    }

    /**
     * Run npm audit scan
     */
    async runNpmAudit(scanId) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            console.log(`[SECURITY] Running npm audit for scan ${scanId}`);
            
            const auditProcess = exec('npm audit --json', {
                timeout: this.config.tools.npmAudit.timeout,
                cwd: process.cwd()
            }, (error, stdout, stderr) => {
                const duration = Date.now() - startTime;
                
                try {
                    // npm audit returns non-zero exit code when vulnerabilities are found
                    // So we need to check if stdout contains valid JSON
                    if (stdout) {
                        const auditData = JSON.parse(stdout);
                        
                        const result = {
                            tool: 'npm-audit',
                            status: 'success',
                            duration,
                            vulnerabilities: this.parseNpmAuditResults(auditData),
                            metadata: {
                                auditReportVersion: auditData.auditReportVersion,
                                vulnerabilities: auditData.metadata?.vulnerabilities || {},
                                dependencies: auditData.metadata?.dependencies || {},
                                totalDependencies: auditData.metadata?.totalDependencies || 0
                            },
                            rawData: auditData
                        };
                        
                        console.log(`[SECURITY] npm audit completed in ${duration}ms`);
                        resolve(result);
                    } else {
                        throw new Error('No output from npm audit');
                    }
                } catch (parseError) {
                    console.error(`[SECURITY] Failed to parse npm audit results:`, parseError);
                    reject(new Error(`npm audit parsing failed: ${parseError.message}`));
                }
            });
            
            auditProcess.on('error', (error) => {
                console.error(`[SECURITY] npm audit process error:`, error);
                reject(error);
            });
        });
    }

    /**
     * Run better-npm-audit scan
     */
    async runBetterNpmAudit(scanId) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            console.log(`[SECURITY] Running better-npm-audit for scan ${scanId}`);
            
            const auditProcess = exec('npx better-npm-audit audit --json', {
                timeout: this.config.tools.betterNpmAudit.timeout,
                cwd: process.cwd()
            }, (error, stdout, stderr) => {
                const duration = Date.now() - startTime;
                
                try {
                    if (stdout) {
                        const auditData = JSON.parse(stdout);
                        
                        const result = {
                            tool: 'better-npm-audit',
                            status: 'success',
                            duration,
                            vulnerabilities: this.parseBetterNpmAuditResults(auditData),
                            metadata: auditData.metadata || {},
                            rawData: auditData
                        };
                        
                        console.log(`[SECURITY] better-npm-audit completed in ${duration}ms`);
                        resolve(result);
                    } else {
                        // better-npm-audit might not return JSON in all cases
                        const result = {
                            tool: 'better-npm-audit',
                            status: 'success',
                            duration,
                            vulnerabilities: [],
                            metadata: { message: 'No vulnerabilities found or different output format' },
                            rawOutput: stderr || 'No output'
                        };
                        resolve(result);
                    }
                } catch (parseError) {
                    console.error(`[SECURITY] Failed to parse better-npm-audit results:`, parseError);
                    // Try to extract information from stderr
                    const result = {
                        tool: 'better-npm-audit',
                        status: 'partial',
                        duration,
                        vulnerabilities: [],
                        metadata: { parseError: parseError.message, stderr },
                        rawOutput: stdout || stderr
                    };
                    resolve(result);
                }
            });
            
            auditProcess.on('error', (error) => {
                console.error(`[SECURITY] better-npm-audit process error:`, error);
                reject(error);
            });
        });
    }

    /**
     * Run audit-ci scan
     */
    async runAuditCi(scanId) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            console.log(`[SECURITY] Running audit-ci for scan ${scanId}`);
            
            // audit-ci with configuration for different severity levels
            const auditProcess = exec('npx audit-ci --config ./audit-ci.json || echo "audit-ci-completed"', {
                timeout: this.config.tools.auditCi.timeout,
                cwd: process.cwd()
            }, (error, stdout, stderr) => {
                const duration = Date.now() - startTime;
                
                try {
                    // audit-ci returns different outputs, parse what we can
                    const result = {
                        tool: 'audit-ci',
                        status: 'success',
                        duration,
                        vulnerabilities: this.parseAuditCiResults(stdout, stderr),
                        metadata: {
                            exitCode: error ? error.code : 0,
                            stdout: stdout,
                            stderr: stderr
                        },
                        rawOutput: stdout + '\n' + stderr
                    };
                    
                    console.log(`[SECURITY] audit-ci completed in ${duration}ms`);
                    resolve(result);
                } catch (parseError) {
                    console.error(`[SECURITY] Failed to parse audit-ci results:`, parseError);
                    reject(parseError);
                }
            });
            
            auditProcess.on('error', (error) => {
                console.error(`[SECURITY] audit-ci process error:`, error);
                reject(error);
            });
        });
    }

    /**
     * Parse npm audit results into standardized format
     */
    parseNpmAuditResults(auditData) {
        const vulnerabilities = [];
        
        if (auditData.vulnerabilities) {
            Object.entries(auditData.vulnerabilities).forEach(([packageName, vulnData]) => {
                vulnData.via.forEach(via => {
                    if (typeof via === 'object' && via.title) {
                        vulnerabilities.push({
                            id: via.url ? via.url.split('/').pop() : crypto.randomBytes(8).toString('hex'),
                            title: via.title,
                            severity: vulnData.severity,
                            packageName: packageName,
                            vulnerableVersions: vulnData.range,
                            patchedVersions: via.range || 'Unknown',
                            overview: via.title,
                            recommendation: `Update ${packageName} to a non-vulnerable version`,
                            references: via.url ? [via.url] : [],
                            cwe: via.cwe || [],
                            cvss: via.cvss || null,
                            source: 'npm-audit'
                        });
                    }
                });
            });
        }
        
        return vulnerabilities;
    }

    /**
     * Parse better-npm-audit results
     */
    parseBetterNpmAuditResults(auditData) {
        // better-npm-audit may have different output format
        // Adapt based on actual output structure
        const vulnerabilities = [];
        
        if (auditData.advisories) {
            Object.entries(auditData.advisories).forEach(([id, advisory]) => {
                vulnerabilities.push({
                    id: id,
                    title: advisory.title,
                    severity: advisory.severity,
                    packageName: advisory.module_name,
                    vulnerableVersions: advisory.vulnerable_versions,
                    patchedVersions: advisory.patched_versions,
                    overview: advisory.overview,
                    recommendation: advisory.recommendation,
                    references: advisory.references ? advisory.references.map(ref => ref.url) : [],
                    cwe: advisory.cwe ? [advisory.cwe] : [],
                    cvss: advisory.cvss,
                    source: 'better-npm-audit'
                });
            });
        }
        
        return vulnerabilities;
    }

    /**
     * Parse audit-ci results
     */
    parseAuditCiResults(stdout, stderr) {
        const vulnerabilities = [];
        
        // audit-ci typically outputs summary information
        // Parse based on the actual output format
        const lines = (stdout + stderr).split('\n');
        
        lines.forEach(line => {
            // Look for vulnerability patterns in the output
            if (line.includes('vulnerability') || line.includes('advisory')) {
                // Extract basic information if available
                const match = line.match(/(\w+)\s+vulnerability/);
                if (match) {
                    vulnerabilities.push({
                        id: crypto.randomBytes(8).toString('hex'),
                        title: line.trim(),
                        severity: match[1].toLowerCase(),
                        packageName: 'Unknown',
                        overview: line.trim(),
                        source: 'audit-ci'
                    });
                }
            }
        });
        
        return vulnerabilities;
    }

    /**
     * Aggregate vulnerabilities from all tools
     */
    aggregateVulnerabilities(summary, toolResult) {
        if (toolResult.vulnerabilities) {
            toolResult.vulnerabilities.forEach(vuln => {
                summary.totalVulnerabilities++;
                
                switch (vuln.severity?.toLowerCase()) {
                    case 'critical':
                        summary.critical++;
                        break;
                    case 'high':
                        summary.high++;
                        break;
                    case 'moderate':
                    case 'medium':
                        summary.moderate++;
                        break;
                    case 'low':
                        summary.low++;
                        break;
                    default:
                        summary.info++;
                }
            });
        }
    }

    /**
     * Generate security recommendations based on scan results
     */
    generateRecommendations(scanResults) {
        const recommendations = [];
        const summary = scanResults.summary;
        
        // Critical vulnerabilities
        if (summary.critical > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                type: 'immediate_action',
                message: `${summary.critical} critical vulnerabilities found. Immediate action required.`,
                actions: [
                    'Stop deployment if in CI/CD pipeline',
                    'Review and update affected packages immediately',
                    'Consider hotfix deployment for critical systems'
                ]
            });
        }
        
        // High severity vulnerabilities
        if (summary.high > this.alertThresholds.high) {
            recommendations.push({
                priority: 'HIGH',
                type: 'urgent_update',
                message: `${summary.high} high severity vulnerabilities exceed threshold (${this.alertThresholds.high})`,
                actions: [
                    'Schedule security update within 24 hours',
                    'Review vulnerable packages for alternatives',
                    'Update security monitoring alerts'
                ]
            });
        }
        
        // General recommendations
        if (summary.totalVulnerabilities > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                type: 'maintenance',
                message: 'Regular security maintenance recommended',
                actions: [
                    'Run dependency updates weekly',
                    'Enable automated security alerts',
                    'Review and update pinned package versions',
                    'Consider using package-lock.json for version control'
                ]
            });
        }
        
        // Tool-specific recommendations
        Object.entries(scanResults.tools).forEach(([toolName, result]) => {
            if (result.error) {
                recommendations.push({
                    priority: 'LOW',
                    type: 'tool_maintenance',
                    message: `${toolName} scanner encountered errors`,
                    actions: [
                        `Check ${toolName} configuration`,
                        'Verify tool installation and updates',
                        'Review scanner logs for details'
                    ]
                });
            }
        });
        
        return recommendations;
    }

    /**
     * Check compliance against security thresholds
     */
    checkCompliance(summary) {
        const compliance = {
            passed: true,
            score: 100,
            violations: []
        };
        
        Object.entries(this.alertThresholds).forEach(([severity, threshold]) => {
            const count = summary[severity] || 0;
            if (count > threshold) {
                compliance.passed = false;
                compliance.violations.push({
                    severity,
                    count,
                    threshold,
                    message: `${count} ${severity} vulnerabilities exceed threshold of ${threshold}`
                });
                
                // Reduce compliance score based on severity
                const severityWeights = { critical: 50, high: 25, moderate: 10, low: 5 };
                const weight = severityWeights[severity] || 1;
                compliance.score -= (count - threshold) * weight;
            }
        });
        
        compliance.score = Math.max(0, compliance.score);
        return compliance;
    }

    /**
     * Save scan results to multiple formats
     */
    async saveResults(scanResults) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const baseFileName = `vulnerability-scan-${scanResults.scanId}-${timestamp}`;
        
        try {
            // Save JSON format (always)
            const jsonPath = path.join(this.config.reporting.outputDir, `${baseFileName}.json`);
            await fs.writeJSON(jsonPath, scanResults, { spaces: 2 });
            console.log(`[SECURITY] Scan results saved to ${jsonPath}`);
            
            // Save other formats if requested
            if (this.config.reporting.formats.includes('csv')) {
                await this.saveResultsAsCSV(scanResults, baseFileName);
            }
            
            if (this.config.reporting.formats.includes('html')) {
                await this.saveResultsAsHTML(scanResults, baseFileName);
            }
            
            // Clean up old reports
            await this.cleanupOldReports();
            
        } catch (error) {
            console.error('[SECURITY] Failed to save scan results:', error);
            throw error;
        }
    }

    /**
     * Save results as CSV format
     */
    async saveResultsAsCSV(scanResults, baseFileName) {
        const csvWriter = require('fast-csv');
        const csvPath = path.join(this.config.reporting.outputDir, `${baseFileName}.csv`);
        
        // Flatten vulnerabilities for CSV
        const csvData = [];
        Object.entries(scanResults.tools).forEach(([toolName, result]) => {
            if (result.vulnerabilities) {
                result.vulnerabilities.forEach(vuln => {
                    csvData.push({
                        scanId: scanResults.scanId,
                        timestamp: scanResults.timestamp,
                        tool: toolName,
                        vulnerabilityId: vuln.id,
                        title: vuln.title,
                        severity: vuln.severity,
                        packageName: vuln.packageName,
                        vulnerableVersions: vuln.vulnerableVersions,
                        patchedVersions: vuln.patchedVersions,
                        recommendation: vuln.recommendation
                    });
                });
            }
        });
        
        return new Promise((resolve, reject) => {
            csvWriter.writeToPath(csvPath, csvData, { headers: true })
                .on('error', reject)
                .on('finish', () => {
                    console.log(`[SECURITY] CSV report saved to ${csvPath}`);
                    resolve();
                });
        });
    }

    /**
     * Save results as HTML format
     */
    async saveResultsAsHTML(scanResults, baseFileName) {
        const htmlPath = path.join(this.config.reporting.outputDir, `${baseFileName}.html`);
        
        const html = this.generateHTMLReport(scanResults);
        await fs.writeFile(htmlPath, html);
        console.log(`[SECURITY] HTML report saved to ${htmlPath}`);
    }

    /**
     * Generate HTML report
     */
    generateHTMLReport(scanResults) {
        const { summary, tools, recommendations, compliance } = scanResults;
        
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Vulnerability Report - ${scanResults.scanId}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .header { text-align: center; margin-bottom: 30px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .summary-card { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .critical { background: #dc3545; color: white; }
        .high { background: #fd7e14; color: white; }
        .moderate { background: #ffc107; color: black; }
        .low { background: #28a745; color: white; }
        .compliance { margin: 20px 0; padding: 20px; border-radius: 8px; }
        .compliance.passed { background: #d4edda; border: 1px solid #c3e6cb; }
        .compliance.failed { background: #f8d7da; border: 1px solid #f5c6cb; }
        .recommendations { margin: 20px 0; }
        .recommendation { margin: 10px 0; padding: 15px; border-left: 4px solid #007bff; background: #f8f9fa; }
        .tool-results { margin: 20px 0; }
        .tool-result { margin: 15px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 5px; }
        .vulnerability { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #dee2e6; padding: 8px; text-align: left; }
        th { background: #e9ecef; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Security Vulnerability Report</h1>
            <p>Scan ID: ${scanResults.scanId}</p>
            <p>Generated: ${new Date(scanResults.timestamp).toLocaleString()}</p>
            <p>Duration: ${scanResults.duration}ms</p>
        </div>
        
        <div class="summary">
            <div class="summary-card critical">
                <h3>Critical</h3>
                <h2>${summary.critical}</h2>
            </div>
            <div class="summary-card high">
                <h3>High</h3>
                <h2>${summary.high}</h2>
            </div>
            <div class="summary-card moderate">
                <h3>Moderate</h3>
                <h2>${summary.moderate}</h2>
            </div>
            <div class="summary-card low">
                <h3>Low</h3>
                <h2>${summary.low}</h2>
            </div>
        </div>
        
        <div class="compliance ${compliance.passed ? 'passed' : 'failed'}">
            <h3>Compliance Status: ${compliance.passed ? 'PASSED' : 'FAILED'}</h3>
            <p>Score: ${compliance.score}/100</p>
            ${compliance.violations.map(v => `<p>⚠ ${v.message}</p>`).join('')}
        </div>
        
        <div class="recommendations">
            <h3>Recommendations</h3>
            ${recommendations.map(rec => `
                <div class="recommendation">
                    <h4>${rec.priority}: ${rec.message}</h4>
                    <ul>
                        ${rec.actions.map(action => `<li>${action}</li>`).join('')}
                    </ul>
                </div>
            `).join('')}
        </div>
        
        <div class="tool-results">
            <h3>Tool Results</h3>
            ${Object.entries(tools).map(([toolName, result]) => `
                <div class="tool-result">
                    <h4>${toolName} (${result.duration || 'N/A'}ms)</h4>
                    ${result.error ? `<p style="color: red;">Error: ${result.error}</p>` : ''}
                    ${result.vulnerabilities ? `
                        <p>Found ${result.vulnerabilities.length} vulnerabilities</p>
                        ${result.vulnerabilities.slice(0, 10).map(vuln => `
                            <div class="vulnerability">
                                <strong>${vuln.title}</strong> (${vuln.severity})<br>
                                Package: ${vuln.packageName}<br>
                                ${vuln.recommendation}
                            </div>
                        `).join('')}
                        ${result.vulnerabilities.length > 10 ? `<p>... and ${result.vulnerabilities.length - 10} more</p>` : ''}
                    ` : ''}
                </div>
            `).join('')}
        </div>
    </div>
</body>
</html>`;
    }

    /**
     * Clean up old report files
     */
    async cleanupOldReports() {
        try {
            const files = await fs.readdir(this.config.reporting.outputDir);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - this.config.reporting.retentionDays);
            
            for (const file of files) {
                const filePath = path.join(this.config.reporting.outputDir, file);
                const stats = await fs.stat(filePath);
                
                if (stats.mtime < cutoffDate) {
                    await fs.remove(filePath);
                    console.log(`[SECURITY] Cleaned up old report: ${file}`);
                }
            }
        } catch (error) {
            console.error('[SECURITY] Failed to cleanup old reports:', error);
        }
    }

    /**
     * Check and send alerts based on scan results
     */
    async checkAndSendAlerts(scanResults) {
        if (!this.config.automation.alertingEnabled) {
            return;
        }
        
        const { summary, compliance } = scanResults;
        
        // Determine if alerts should be sent
        const shouldAlert = !compliance.passed || 
                           summary.critical > 0 || 
                           summary.high > this.alertThresholds.high;
        
        if (shouldAlert) {
            console.log('[SECURITY] Sending security alerts...');
            
            const alertData = {
                scanId: scanResults.scanId,
                timestamp: scanResults.timestamp,
                severity: summary.critical > 0 ? 'CRITICAL' : 'HIGH',
                summary: summary,
                compliance: compliance,
                topRecommendations: scanResults.recommendations.slice(0, 3)
            };
            
            // Send alerts through configured channels
            if (this.config.automation.slackWebhook) {
                await this.sendSlackAlert(alertData);
            }
            
            if (this.config.automation.emailAlerts) {
                await this.sendEmailAlert(alertData);
            }
        }
    }

    /**
     * Send Slack alert
     */
    async sendSlackAlert(alertData) {
        // Implementation would depend on Slack webhook setup
        console.log('[SECURITY] Slack alert would be sent:', alertData.severity);
    }

    /**
     * Send email alert
     */
    async sendEmailAlert(alertData) {
        // Implementation would depend on email service setup
        console.log('[SECURITY] Email alert would be sent:', alertData.severity);
    }

    /**
     * Get scan history
     */
    getScanHistory() {
        return this.scanHistory;
    }

    /**
     * Get latest scan results
     */
    getLatestResults() {
        return this.lastScanResults;
    }

    /**
     * Get security metrics for dashboard
     */
    getSecurityMetrics() {
        if (!this.lastScanResults) {
            return null;
        }
        
        const { summary, compliance, timestamp } = this.lastScanResults;
        
        return {
            lastScanTime: timestamp,
            totalVulnerabilities: summary.totalVulnerabilities,
            criticalVulnerabilities: summary.critical,
            highVulnerabilities: summary.high,
            complianceScore: compliance.score,
            compliancePassed: compliance.passed,
            riskLevel: this.calculateRiskLevel(summary),
            trendData: this.calculateTrends()
        };
    }

    /**
     * Calculate overall risk level
     */
    calculateRiskLevel(summary) {
        if (summary.critical > 0) return 'CRITICAL';
        if (summary.high > this.alertThresholds.high) return 'HIGH';
        if (summary.moderate > this.alertThresholds.moderate) return 'MEDIUM';
        return 'LOW';
    }

    /**
     * Calculate security trends from scan history
     */
    calculateTrends() {
        if (this.scanHistory.length < 2) {
            return { trend: 'insufficient_data' };
        }
        
        const recent = this.scanHistory.slice(-5); // Last 5 scans
        const vulnerabilityCounts = recent.map(scan => scan.summary.totalVulnerabilities);
        
        const trend = vulnerabilityCounts[vulnerabilityCounts.length - 1] > vulnerabilityCounts[0] 
            ? 'increasing' : 'decreasing';
        
        return {
            trend,
            recentScans: recent.length,
            averageVulnerabilities: vulnerabilityCounts.reduce((a, b) => a + b, 0) / vulnerabilityCounts.length
        };
    }
}

// ==================== EXPORTS ====================

module.exports = {
    VulnerabilityScanner,
    VULNERABILITY_CONFIG
};